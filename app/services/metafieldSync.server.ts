import prisma from "../db.server";
import { authenticate } from "../shopify.server";
import { Decimal } from "@prisma/client/runtime/library";

/**
 * Sync credit data to Shopify metafields
 * This allows the checkout extension to read credit limits without external API calls
 */

interface MetafieldUpdate {\n  namespace: string;\n  key: string;\n  value: string;\n  type: string;\n}\n\n/**\n * Create or update customer metafields for credit information\n */\nexport async function syncCustomerCreditMetafields(\n  admin: any,\n  customerId: string,\n  userId: string\n) {\n  try {\n    // Get user credit info from database\n    const user = await prisma.user.findUnique({\n      where: { id: userId },\n      select: {\n        userCreditLimit: true,\n        userCreditUsed: true,\n        companyId: true,\n      },\n    });\n\n    if (!user) {\n      throw new Error('User not found');\n    }\n\n    // Prepare metafields to update\n    const metafields: MetafieldUpdate[] = [\n      {\n        namespace: 'b2b_credit',\n        key: 'is_b2b_customer',\n        value: 'true',\n        type: 'single_line_text_field',\n      },\n      {\n        namespace: 'b2b_credit',\n        key: 'company_id',\n        value: user.companyId,\n        type: 'single_line_text_field',\n      },\n      {\n        namespace: 'b2b_credit',\n        key: 'user_credit_used',\n        value: user.userCreditUsed.toString(),\n        type: 'number_decimal',\n      },\n    ];\n\n    // Add user credit limit if it exists\n    if (user.userCreditLimit) {\n      metafields.push({\n        namespace: 'b2b_credit',\n        key: 'user_credit_limit',\n        value: user.userCreditLimit.toString(),\n        type: 'number_decimal',\n      });\n    }\n\n    // Update customer metafields\n    const mutation = `\n      mutation customerUpdate($input: CustomerInput!) {\n        customerUpdate(input: $input) {\n          customer {\n            id\n            metafields(first: 20) {\n              edges {\n                node {\n                  id\n                  namespace\n                  key\n                  value\n                }\n              }\n            }\n          }\n          userErrors {\n            field\n            message\n          }\n        }\n      }\n    `;\n\n    const customerInput = {\n      id: customerId,\n      metafields: metafields.map(field => ({\n        namespace: field.namespace,\n        key: field.key,\n        value: field.value,\n        type: field.type,\n      })),\n    };\n\n    const response = await admin.graphql(mutation, {\n      variables: { input: customerInput },\n    });\n\n    const data = await response.json();\n\n    if (data.errors || data.data?.customerUpdate?.userErrors?.length > 0) {\n      const error = data.errors?.[0]?.message || data.data?.customerUpdate?.userErrors?.[0]?.message;\n      throw new Error(`Failed to update customer metafields: ${error}`);\n    }\n\n    return { success: true, data: data.data?.customerUpdate?.customer };\n\n  } catch (error) {\n    console.error('Error syncing customer credit metafields:', error);\n    return { success: false, error: error.message };\n  }\n}\n\n/**\n * Create or update company metafields for credit information\n */\nexport async function syncCompanyCreditMetafields(\n  admin: any,\n  companyId: string\n) {\n  try {\n    // Get company credit info from database\n    const company = await prisma.companyAccount.findUnique({\n      where: { id: companyId },\n      select: {\n        creditLimit: true,\n        shopifyCompanyId: true,\n      },\n    });\n\n    if (!company || !company.shopifyCompanyId) {\n      throw new Error('Company not found or no Shopify company ID');\n    }\n\n    // Calculate used credit\n    const usedCredit = await prisma.b2BOrder.aggregate({\n      where: {\n        companyId,\n        paymentStatus: { in: ['pending', 'partial'] },\n        orderStatus: { notIn: ['cancelled'] },\n      },\n      _sum: {\n        remainingBalance: true,\n      },\n    });\n\n    const creditUsed = usedCredit._sum.remainingBalance || new Decimal(0);\n\n    // Prepare metafields\n    const metafields: MetafieldUpdate[] = [\n      {\n        namespace: 'b2b_credit',\n        key: 'credit_limit',\n        value: company.creditLimit.toString(),\n        type: 'number_decimal',\n      },\n      {\n        namespace: 'b2b_credit',\n        key: 'credit_used',\n        value: creditUsed.toString(),\n        type: 'number_decimal',\n      },\n    ];\n\n    // Update company metafields\n    const mutation = `\n      mutation companyUpdate($companyId: ID!, $input: CompanyInput!) {\n        companyUpdate(companyId: $companyId, input: $input) {\n          company {\n            id\n            metafields(first: 20) {\n              edges {\n                node {\n                  id\n                  namespace\n                  key\n                  value\n                }\n              }\n            }\n          }\n          userErrors {\n            field\n            message\n          }\n        }\n      }\n    `;\n\n    const companyInput = {\n      metafields: metafields.map(field => ({\n        namespace: field.namespace,\n        key: field.key,\n        value: field.value,\n        type: field.type,\n      })),\n    };\n\n    const response = await admin.graphql(mutation, {\n      variables: { \n        companyId: company.shopifyCompanyId,\n        input: companyInput \n      },\n    });\n\n    const data = await response.json();\n\n    if (data.errors || data.data?.companyUpdate?.userErrors?.length > 0) {\n      const error = data.errors?.[0]?.message || data.data?.companyUpdate?.userErrors?.[0]?.message;\n      throw new Error(`Failed to update company metafields: ${error}`);\n    }\n\n    return { success: true, data: data.data?.companyUpdate?.company };\n\n  } catch (error) {\n    console.error('Error syncing company credit metafields:', error);\n    return { success: false, error: error.message };\n  }\n}\n\n/**\n * Sync both customer and company credit metafields\n */\nexport async function syncAllCreditMetafields(\n  shop: string,\n  customerId: string,\n  userId: string\n) {\n  try {\n    const { admin } = await authenticate.admin(shop);\n\n    // Get user to find company\n    const user = await prisma.user.findUnique({\n      where: { id: userId },\n      select: { companyId: true },\n    });\n\n    if (!user) {\n      throw new Error('User not found');\n    }\n\n    // Sync customer metafields\n    const customerResult = await syncCustomerCreditMetafields(\n      admin,\n      customerId,\n      userId\n    );\n\n    // Sync company metafields\n    const companyResult = await syncCompanyCreditMetafields(\n      admin,\n      user.companyId\n    );\n\n    return {\n      success: customerResult.success && companyResult.success,\n      customer: customerResult,\n      company: companyResult,\n    };\n\n  } catch (error) {\n    console.error('Error syncing all credit metafields:', error);\n    return { \n      success: false, \n      error: error.message,\n      customer: { success: false },\n      company: { success: false },\n    };\n  }\n}\n\n/**\n * Auto-sync metafields when credit data changes\n * Call this function whenever credit limits or usage changes\n */\nexport async function autoSyncCreditMetafields(\n  companyId: string,\n  userId?: string\n) {\n  try {\n    // Get all users in the company if specific user not provided\n    const users = userId \n      ? [{ id: userId, shopifyCustomerId: null }]\n      : await prisma.user.findMany({\n          where: {\n            companyId,\n            isActive: true,\n            shopifyCustomerId: { not: null },\n          },\n          select: {\n            id: true,\n            shopifyCustomerId: true,\n          },\n        });\n\n    // Get company info\n    const company = await prisma.companyAccount.findUnique({\n      where: { id: companyId },\n      select: {\n        shop: {\n          select: { domain: true }\n        }\n      },\n    });\n\n    if (!company?.shop?.domain) {\n      throw new Error('Company shop not found');\n    }\n\n    const results = [];\n\n    // Sync metafields for each user\n    for (const user of users) {\n      if (user.shopifyCustomerId) {\n        const result = await syncAllCreditMetafields(\n          company.shop.domain,\n          user.shopifyCustomerId,\n          user.id\n        );\n        results.push({ userId: user.id, result });\n      }\n    }\n\n    return {\n      success: true,\n      syncedUsers: results.length,\n      results,\n    };\n\n  } catch (error) {\n    console.error('Error in auto-sync credit metafields:', error);\n    return {\n      success: false,\n      error: error.message,\n      syncedUsers: 0,\n      results: [],\n    };\n  }\n}
